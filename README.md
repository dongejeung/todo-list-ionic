# TO-DO-LIST IONICE

## 배포 URL

https://dreamy-hopper-f4611b.netlify.com

## 요구사항

- 내용을 입력하고, 추가 버튼을 눌러서 할일을 추가한다. (1 준호가 구현해줌)

- 삭제 버튼을 눌러서 할일을 삭제할 수 있다.

- 완료한 일은 완료처리를 한다.

- 완료 처리한 일은 다른 탭에서 확인할 수 있다.

- 내용을 저장할 시에는 localStorage를 활용한다.(1 준호가 구현해줌.)

- 웹 사이트 배포(NETLIFY)

## Getting Started

```
npm i -g @ionic/cli
npm i -g yarn
yarn
yarn start
```

## 개발일정
*일주일 단위

2020/04/14 ~ 2020/04/19

1. 준호 작성 요구사항.
2. 아이오닉 컴포넌트 중 사용할 만한 것들 리스팅. (https://ionicframework.com/docs/)
3. 2번 케이스 테스트 케이스 작성.

=====

2020/04/15

1. 로컬 스토리지에 저장된 json 패턴 파악.
=> 코드에 console.log 넣어서 저장형태 파악.
["1241245125","26136136","","345345345","1232323","234234","123123","23252"] 
배열의 형태.
=> parse 를 통해 가져왔을 시 index : "213251" 의 형태.
* js 는 이것저것 데이터 집어 넣어 보는게 빠를 수 있음.

2. 삭제시에는 index를 기반으로 localstorage 데이터를 삭제해야함.
개발자도구에서 localstorage 입력후 content assistant를 통해 유추.
안되면 검색.
검색했더니 보통 localstorage를 사용할때는 key : value 의 형태로 사용을 하는 것 같다.
기존에 준호가 작성해준 코드에서도 key value 로 했으나, savedList 라는 키에 배열식으로 넣었었나 보다.
버튼형태를 타이틀/ 컨텐트 식으로 해서 key value 의 형태로 넣는 것이 어떨까 생각해본다.

* 근데 개발자도구에서 remove(savedList) 썼더니 에러가 나네.. ㅋㅋㅋㅋ
=> localstorage에 값이 없어서 그런가 싶어서 하나 넣어줘볼까..
L.20 JSON.parse 에서 에러 발생.
unexpected end of JSON
removeItem을 통해서 비워놨던 데이터를 JSON 형태라 가정하고 파싱해서 그런 것으로 예상.

=> 예상이 맞음. useState의 개념에는 아직 익숙하지 않지만, 
localStorage.setItem('savedList', JSON.stringify(["sample"]));
라고 개발자 도구에 초기값을 입의로 넣어주니 레이아웃이 동작.

3. 데이터 삭제 기능을 개발자 도구로 러프 테스트.

뭔가 좋은 형태는 아닌 것 같지만, 로컬스토리지에서 데이터를 불러와서,
거기서 삭제를 한 후 다시 로컬스토리지로 집어 넣는 것이 바로 생각남.

useState 와 ES6 문법, 컨텍스트의 개념 등으로 인해 개발자 도구에서 러프하게 빼는 것 실패.
=> 기초 개념 공부하기로 함.

// 물론. 인풋의 형태를 타이틀 / 컨텐트 로 구분하는 경우와 아닐 경우가 달라질 수 있다.
데이터 저장 방식에 대해서는 생각해볼 필요가 있다. 일단 삭제 기능 테스트 부터.

4. 이후 삭제 버튼을 docs 에서 찾아서 기능과 연동.

2020/04/16

* 데이터 이동과 가공시 마다 타입의 범위를 고려해두는 시스템을 생각해보면 좋을 것 같음.

* 일단 준호가 보내준 react, ES6 등 기본자료 훝어보기.

===

docs 에서 삭제버튼을 계속 못찾겠다..

2020/04/17

어제 버튼형태를 찾아 넣기는 했었음.
*근데 버튼은 다 같은 버튼이고 형태나 기능은 지가 넣으면 되는 거였음.

5. JSON.stringigy, JSON.parse 를 몇 번 테스트 케이스 해봄.
아마 객체 배열의 형태로 넣야되지 싶음.

개발자 도구 테스트 :
JSON.stringify([{title : "12313", contents : "1231243"}, {title : "ti2", contents : "tada"}]);
"[{"title":"12313","contents":"1231243"},{"title":"ti2","contents":"tada"}]"

이걸 다시 parse 하려니까 안되네.
=> 검색했다.
배열, 혹은 객체를 담네..

ref)
https://mkil.tistory.com/322

아 요거 참고하면 될 듯.

이제 로컬스토리지에 담고 빼고 해보면 될 듯.

-------

2020/04/18

낮에 하다가 잘 안된 것을 준호가 도와줌.

타입스크립트를 쓰고 있는데.. 
내가 타입스크립트를 쓰고 있다는 걸 인지를 못했네;;

뭐 자바 문법같은게 (제너릭하고 클래스 같이 생긴게) 들어가고 그러네..;;

삭제버튼 css하고 기능 이상하게 만들어 놓음.

하나만 남기고 다 지워짐..

list.map 안에 del 버튼이 있어서 그런가 추론은 하는데..

// 개발도 간만인데 ES6, react, typescript 다 모르는 것이니.. 초반에 좀 헤맬수도 있겠네..

=======

2020/04/19

준호가 도와줘서 삭제 기능 완성.
예상과는 다르게 list.map 내부에 있어서 그런 것은 아니었음.
아래 추가 버튼 코드를 복사해서 하다 보니..
const newList = [{title, content}, ...list]
라는 요소를 복붙 했는데..
이게 잘못 됐던 듯.


=======

2020/04/20

체크박스는 때려 넣는데..
값 조작 셋팅이 안되네..

=======

2020/04/22

객체배열의 특정 값 수정.
https://velopert.com/3638

근데 왜 array.[i] 이런 식으로 배열의 인자에 접근하는 게 안되지..

예시 보면 다들 id를 배열의 인자번호 같이 쓰는 것 같네..

객체 배열이라 그런가..

객체에 cardNum 이라는 요소 추가하고,
추가버튼 누를시
setCardNum(list.length+1)
로 카드번호 부여해줌.

-----
- number 초기값 셋팅으로 로컬스토리지 배열의 길이를 대입.

const [cardNum, setCardNum] = useState<number>(savedList.length);
-----
* 카드의 번호를 i의 역순으로 하고 싶음.
전체 배열의 길이를 구하고 -1 씩 뺴서 돌려야되나..
일단 스킵하고,
-----
- 상단 카드 번호 표시되는 것 일단 빼버림.
나중에 번호가 겹칠 우려가 있을 것으로 예상.
-----
- 체크 누를시 해당 배열의 인자의 checked 값 true로 변경.

역시 콘솔로그가 짱이다.
console.log(e)
를 통해서 스코프 안에 무엇들이 들어있는지 파악했다.
내가 찾는 checked 의 값이
e.detail.checked 안에 들어 있다.
e라는 것이 본인의 태그 안에 형성되어 있다.

// 아 샛길로 빠져서, 형태 바꾸고 있네;;

e에 들어있는 값은 check에 대한 값밖에 없는데..

체크하는 것 자체 이벤트로 배열에 적절한 값을 대체하는 건 
잘 안될지도 모르겠다.
일단 체크한 상태로 추가를 하면 변경점 있는지 보자.
true 값이 들어가 있는지 보려고 한다.
=> 안 들어감.
-----
일단
const newList = list.map(item => item.cardNum === v.cardNum
    ? ({ ...item, checked: e.detail.checked }) 
    : item)

코드로 인해서 배열 안에 checked 값이 변하게는 해 놓았다.
근데 왜 체크 표시는 사라지니?

개인적으로 삼항 연산자 안좋아하긴 하는데..

-----
할일 
1. newList에는 checked 값이 true, false 로 의도한대로 바뀌나,
setChecked(e.detail.checked)
을 사용할 경우, 둘 다 체크상태로 보여지고,
해당 문장을 해제할 경우,
둘다 체크해제 상태로 보이게 된다.

2. cardNum에 unique 값 부여하기.
=> 배열의 cardNum중에서 최대값을 찾아서 거기서 1증가한 값을 cardNum에 
삽입하는 수식을 생각함.


2020/04/23

아 체크가 사리지는 이유를 대충 추론했다.
아 헷갈리는데..
그냥 저장 버튼을 만들까.
아까 배열 콘솔로그가 포문 돌기도 한것 같은데..
setChecked 사용시
루프 돌아서 들어가네..
사용 안해도 루프가 돌아가는 구나..

setChecked 는 사용 안하는게 맞는 것 같고..
이게 왜 두바퀴씩 돌아가지?
클릭을 하면 값이 바뀌었다가.
다시 바뀌네..
아 카드넘 중복때매 그런가..
아닌데.. 하나만 있어도 그러네..

아 해결했다. 
이게 복붙의 폐해다.
checked={checked} 
태그 안에 이게 있어서 그런가 보다.
대입이 두번 일어나서 그런 듯.
---
됐다. 체크가 연속으로 안일어나고,
새고고침해도 체크가 남아있다.
const [checked, setChecked] = useState<boolean>(false);
<IonCheckbox checked={v.checked}


---

unique 값 부여는 후순위로 미루고,
tab3에 체크된 리스트만 표시하는 것을 먼저 해보자.

됐다.
tab3 상단에
const newlist = list.filter((v, ii) => v.checked === true);
하고 카드 그려줄때 newList.map 으로 그려줬다.
---
자동 렌더링은 새로고침 해줘야 된다.
