ref)
https://www.tutorialspoint.com/
===

Identifiers in TypeScript
타입스크립트의 식별자 

Identifiers are names given to elements in a program like variables, functions etc. The rules for identifiers are −
변수 함수의 식별자(이름) 짓는 규칙.

Identifiers can include both, characters and digits. However, the identifier cannot begin with a digit.
문자, 숫자 가능하나, 숫자부터 시작하면 안됌.

Identifiers cannot include special symbols except for underscore (_) or a dollar sign ($).
_(언더바)와 $(달러)를 제외한 특수문자 사용불가.

Identifiers cannot be keywords.
예약어(var, function)는 사용 금지.

They must be unique.
유니크 해야함.

Identifiers are case-sensitive.
대소문자 구별됨.

Identifiers cannot contain spaces.
공백 포함 불가능.

===
예약어들

break	as	any	switch
case	if	throw	else
var	number	string	get
module	type	instanceof	typeof
public	private	enum	export
finally	for	while	void
null	super	this	new
in	return	true	false
any	extends	static	let
package	implements	interface	function
new	try	yield	const
continue	do	catch

===
- 세미콜론은 옵션임.
===
Example: TypeScript and Object Orientation

class Greeting { 
   greet():void { 
      console.log("Hello World!!!") 
   } 
} 
var obj = new Greeting(); 
obj.greet();

=> typescript에서는 클래스를 선언해주고, 
greet(매개변수): void(리턴타입인가?)
내부 내용 작성인 듯.

하단은 생성자를 생성해서. 사용함.
(자바와 유사하다고 보면 됨.)

===
On compiling, it will generate following JavaScript code.

//Generated by typescript 1.8.10
var Greeting = (function () {
   function Greeting() {
   }
   Greeting.prototype.greet = function () {
      console.log("Hello World!!!");
   };
	return Greeting;
}());

var obj = new Greeting();
obj.greet()
===
//자바스크립트로 컴파일된 코드는 조금 복잡한 구조임.
블록스코프 리터럴 함수(?)로 Greeting을 선언해주고,

그 내부에 greeting() 이라는 함수를 선언하고,

그 greeting의 프로토타입에 greet라는 실제 함수를 추가해줌.
===

#Type

-- The Any type

-- Built-in types
- Number	number	
- String	string	
- Boolean	boolean	
- Void	    void	
- Undefined	undefined	

-- User-defined Types

- Enumerations (enums)
- classes 
- interfaces
- arrays
- tuple
===
However, null and undefined are not the same. A variable initialized with undefined means that the variable has no value or object assigned to it 
while null means that the variable has been set to an object whose value is undefined.

=> null 과 undefined 차이점.
undefined : 변수를 선언만 하고 초기화를 안해서 값이나 객체가 할당되지 않았다는 의미.
null : 변수의 값이 정의되지 않은 객체에 set(할당 인가?) 되었다는 의미?
null은 아래의 참조문서에서 원시값 중 하나라고 함.
어떤 값이 의도적으로 비어있음을 의미.

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/null
위를 참조하면 좋을 듯.
===
Variable Declaration Syntax & Description
1.	
var name:string = ”mary”

The variable stores a value of type string
=> 타입정해서 선언 + 할당.

2.	
var name:string;

The variable is a string variable. The variable’s value is set to undefined by default
=> 타입 정해서 선언만 하고 값은 undefined

3.	
var name = ”mary”

The variable’s type is inferred(유추하다.) from the data type of the value. Here, the variable is of the type string
=> 타입 유추.

4.	
var name;

The variable’s data type is any. Its value is set to undefined by default.
=> any type.
===
#캐스팅

Type Assertion in TypeScript
var str = '1' 
var str2:number = <number> <any> str   //str is now of type number 
console.log(typeof(str2))

=> 해당 예시는 에러가 남.
일단 제너릭(<>) 형태에서는 에러가 나고,
as를 사용해서 any 로 변환 하는 등으로는 사용이 되나,
실제 타입 변경을 위해서는 아래와 같이 함수를 사용하거나 해야하는 듯.

Number('1234')
var y = String(1234)

var x = "32";
var y = +x; 
===
TypeScript Variable Scope

- Global Scope

- Class Scope

- Local Scope
=====
연산자나 기본적인 것은 js 와 동일한 것들이 많아서 스킵.
=====
#Function

function disp_details(id:number,name:string,mail_id?:string) { 
   
}

=> 함수의 매개변수로 type을 지정해야 하는데,
?를 붙일 경우 필수 매개변수가 아님.(옵션이다.)
옵션 변수는 끝쪽에 위치해야 함.
-----

Rest Parameters

function addNumbers(...nums:number[]) {  
   var i;   
   var sum:number = 0; 
   
   for(i = 0;i<nums.length;i++) { 
      sum = sum + nums[i]; 
   } 
   console.log("sum of the numbers",sum) 
} 
addNumbers(1,2,3) 
addNumbers(10,10,10,10,10)

=> ... 을 통해서 여러인자를 간단하게 삽입해줌.
 다만 인자들의 타입은 같아야 함.
 ---
 Default Parameters

 function calculate_discount(price:number,rate:number = 0.50) { 
   var discount = price * rate; 
   console.log("Discount Amount: ",discount); 
} 
calculate_discount(1000) 
calculate_discount(1000,0.30)
---
익명함수 생략..
---
The Function Constructor

var myFunction = new Function("a", "b", "return a * b"); 
var x = myFunction(4, 3); 
console.log(x);

=> 생성자 같은건가? 왜 인자를 스트링으로 넘겨주는지는 잘 모르겠다.
 역시 예상대로 eval이라서 그런 것 같다.(돌려봄. 컴파일러에서 경고문으로 알려줌.)
 잘 사용할 것 같지는 않은 형태다.
 예전에 eval 형태는 code injection 이라는 보안형태에 취약하다고 들었던 것 같다.
---
#재귀 함수 생략.
---
#람다 함수.(소위 화살표 함수로 불리는 것. 기볻은 익명함수임.)
// 이건 말이 람다함순데, 결국 리터럴 타입으로 함수를 선언해서 변수의 이름값으로 함수에 접근해서 재사용이 가능한 형태다.

( [param1, parma2,…param n] )=>statement;

var foo = (x:number)=>10 + x 
console.log(foo(100))      //outputs 110 

=> 함수 내용 길어지면 block {} 처리.
 함수의 매개변수를 
 (x:number) : 일반적인 매개변수 표시.
 x : 파라미터 하나일 때 () 괄호 생략 가능.
 () : 파라미터 없을 땐
---
#Function Overloads (함수 오버로딩.)

The data type of the parameter

function disp(string):void; 
function disp(number):void;
The number of parameters

function disp(n1:number):void; 
function disp(x:number,y:number):void;
The sequence of parameters

function disp(n1:number,s1:string):void; 
function disp(s:string,n:number):void;

ex)

function disp(s1:string):void; 
function disp(n1:number,s1:string):void; 

function disp(x:any,y?:any):void { 
   console.log(x); 
   console.log(y); 
} 
disp("abc") 
disp(1,"xyz");
---
// 그만 보려고 했더니, union type 같이 중요한 것도 나오고 그러네..
---
#number

https://www.tutorialspoint.com/typescript/typescript_numbers.htm
참고.

#string

https://www.tutorialspoint.com/typescript/typescript_strings.htm
참고.
---
#Arrays

 : 같은 데이터 타입의 값들을 모아놓은 것.

 - 메모리 블록을 선언하는 것임.
 - static 이라 한 번 선언되면 사이즈를 바꿀 수 없음.
 - 각각의 메모리 블록이 배열의 요소를 나타냄.
 - 배열은 유니크한 인덱스(번호)로 관리됨.
 - 선언부터 하는 것이 가능.
 - 배열 초기화는 배열 요소를 거주시키는데 참조된다.(뭔 말이지? 좀 헷갈린다.)
 => 배열 초기화는 배열 요소를 채우는 것을 말합니다.(갓구글 번역기. 통문 자연어를 번역해버리네 ㅋㅋㅋㅋ 개편하네.. ㅋㅋㅋㅋ)
 - 배열 요소 값은 업데이트 또는 수정할 수 있지만 삭제할 수는 없습니다.
---
중간 생략...
---
#Array Object (배열객체임) // 객체 배열이 아니라, 객체에 배열을 할당한다고 보면 됨. 객체 배열은 배열의 인자가 객체인 것이고.

ex)
var arr_names:number[] = new Array(4)  // new 로 생성자 만들어줘서 하는가 봄.

for(var i = 0;i<arr_names.length;i++;) { 
   arr_names[i] = i * 2 
   console.log(arr_names[i]) 
}

// 테스트 해봤는데 배열은 type을 union type으로 하든 any로 하든 첫 인자인 string과 다른 타입이 들어가면 에러가 남.
타입이 같아야만 하는 듯.
---
#Array Destructuring (배열 파괴.)

ex)

var arr:number[] = [12,13] 
var[x,y] = arr 
console.log(x) 
console.log(y)

// 요것도 자주 쓰이는 패턴인 것 같음.
배열의 요소를 개별 인자들에 할당해주는 문법인 듯.
테스트 해봤는데 이름처럼  arr이 사라지는 것이 아니라,
개별 인자들에 기존 배열의 인자의 값을 할당해준다고 보면 될 듯.
하단에 
console.log(arr) 입력하니 배열은 건재하다.

* 배열의 주소는 포인터처럼 reference 값으로 관리되기 때문에,
해당 방식으로 사용하면, x, y를 변경할 시 실제 배열에 있는 값이 바뀔 것임.
테스트 해봄.

=> 아니다 값만 할당하게 된다.

js로 컴파일된 코드를 보면 알 수 있다.

ex)

//Generated by typescript 1.8.10
var arr = [12, 13];
var x = arr[0], y = arr[1];   // 해당 부분에서 원시값을 가져다가 때려박는 게 다임.
console.log(x);
console.log(y);

이런 기본기 하나하나가 중요한 것 같다.
---
#배열 순회.

ex)
var j:any; 
var nums:number[] = [1001,1002,1003,1004] 

for(j in nums) {  // 해당 부분이 중요하다.
   console.log(nums[j]) 
} 







